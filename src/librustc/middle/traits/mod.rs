// Copyright 2014 The Rust Project Developers. See the COPYRIGHT
// file at the top-level directory of this distribution and at
// http://rust-lang.org/COPYRIGHT.
//
// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license
// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your
// option. This file may not be copied, modified, or distributed
// except according to those terms.

/*!
 * Trait Resolution. See doc.rs.
 */

use middle::subst;
use middle::ty;
use middle::typeck::infer::InferCtxt;
use std::rc::Rc;
use syntax::ast;
use syntax::codemap::Span;

pub use self::select::SelectionContext;
pub use self::fulfill::FulfillmentContext;
pub use self::fulfill::PendingSelection;
pub use self::fulfill::PendingSelections;
pub use self::fulfill::PendingVtableOrigin;
pub use self::fulfill::PendingVtableOrigins;
pub use self::util::Supertraits;
pub use self::util::supertraits;

mod coherence;
mod fulfill;
mod select;
mod util;

/**
 * An `Obligation` represents some trait reference (e.g. `int:Eq`) for
 * which the vtable must be found.  The process of finding a vtable is
 * called "resolving" the `Obligation`. This process consists of
 * either identifying an `impl` (e.g., `impl Eq for int`) that
 * provides the required vtable, or else finding a bound that is in
 * scope. The eventual result is a `Resolution<VtableOrigin>` (defined
 * below).
 */
#[deriving(Clone)]
pub struct Obligation {
    pub span: Span,
    pub recursion_depth: uint,
    pub trait_ref: Rc<ty::TraitRef>,
}

pub type Obligations = subst::VecPerParamSpace<Obligation>;

pub type Selection = Vtable<Obligation>;

#[deriving(Clone,Show)]
pub enum SelectionError {
    Unimplemented,
    Overflow,
    OutputTypeParameterMismatch(ty::type_err)
}

pub struct FulfillmentError<'o> {
    pub obligation: &'o Obligation,
    pub code: FulfillmentErrorCode
}

pub enum FulfillmentErrorCode {
    SelectionError(SelectionError),
    Ambiguity,
}

/**
 * A fully resolved vtable. This is the data structure that is
 * generated by type checking once everything is complete. It includes
 * both the vtable that matches an obligation and (recursively) fully
 * resolved vtables for all nested obligations.
 */
#[deriving(Show,Clone)]
pub struct VtableOrigin {
    pub vtable: Vtable<VtableOrigin>
}

#[allow(non_snake_case_functions)]
pub fn VtableOrigin(v: Vtable<VtableOrigin>) -> VtableOrigin {
    VtableOrigin { vtable: v }
}

pub type VtableOrigins = subst::VecPerParamSpace<VtableOrigin>;

/**
 * When performing resolution, it is typically the case that there
 * can be one of three outcomes:
 *
 * - `Ok(Some(r))`: success occurred with result `r`
 * - `Ok(None)`: could not definitely determine anything, usually due
 *   to inconclusive type inference.
 * - `Err(e)`: error `e` occurred
 */
pub type SelectionResult<T> = Result<Option<T>,SelectionError>;

#[deriving(PartialEq,Eq,Show)]
pub enum EvaluationResult {
    EvaluatedToMatch,
    EvaluatedToAmbiguity,
    EvaluatedToUnmatch
}

/**
 * Given the successful resolution of an obligation, the
 * `Vtable` indicates where the vtable comes from.
 *
 * For example, the vtable may be tied to a specific impl (case A),
 * or it may be relative to some bound that is in scope (case B).
 *
 *
 * ```
 * impl<T:Clone> Clone<T> for Option<T> { ... } // Impl_1
 * impl<T:Clone> Clone<T> for Box<T> { ... }    // Impl_2
 * impl Clone for int { ... }             // Impl_3
 *
 * fn foo<T:Clone>(concrete: Option<Box<int>>,
 *                 param: T,
 *                 mixed: Option<T>) {
 *
 *    // Case A: Vtable points at a specific impl. Only possible when
 *    // type is concretely known. If the impl itself has bounded
 *    // type parameters, Vtable will carry resolutions for those as well:
 *    concrete.clone(); // Vtable(Impl_1, [Vtable(Impl_2, [Vtable(Impl_3)])])
 *
 *    // Case B: Vtable must be provided by caller. This applies when
 *    // type is a type parameter.
 *    param.clone();    // VtableParam(Oblig_1)
 *
 *    // Case C: A mix of cases A and B.
 *    mixed.clone();    // Vtable(Impl_1, [VtableParam(Oblig_1)])
 * }
 *
 */
#[deriving(Show,Clone)]
pub enum Vtable<N> {
    VtableImpl(VtableImpl<N>),

    // Vtable automatically generated for an unboxed closure. The def
    // ID is the ID of the closure expression.
    VtableUnboxedClosure(ast::DefId),

    /// Successful resolution to an obligation provided by the caller
    /// for some type parameter.
    VtableParam(VtableParam),

    /// Successful resolution for a builtin trait.
    VtableBuiltin,
}

/**
 * Identifies a particular impl in the source, along with a set of
 * substitutions from the impl's type/lifetime parameters. The
 * `nested` vector corresponds to the nested obligations attached to
 * the impl's type parameters.
 */
#[deriving(Clone)]
pub struct VtableImpl<N> {
    pub impl_def_id: ast::DefId,
    pub substs: subst::Substs,
    pub nested: subst::VecPerParamSpace<N>
}

/**
 * A vtable provided as a parameter by the caller. For example, in a
 * function like `fn foo<T:Eq>(...)`, if the `eq()` method is invoked
 * on an instance of `T`, the vtable would be of type `VtableParam`.
 */
#[deriving(Clone)]
pub struct VtableParam {
    // In the above example, this would `Eq`
    pub bound: Rc<ty::TraitRef>,
    pub path: VtablePath,
}

/**
 * A path through the obligation tree for the function. See `doc.rs`.
 */
#[deriving(Show,Clone,Encodable,Decodable)]
pub struct VtablePath {
    pub space: subst::ParamSpace,
    pub obligation: uint,
    pub supertraits: Vec<uint>,
}

pub fn try_select_obligation(infcx: &InferCtxt,
                             param_env: &ty::ParameterEnvironment,
                             obligation: &Obligation)
                             -> SelectionResult<Selection>
{
    /*!
     * Attempts to select the impl/bound/etc for the obligation
     * given. Returns `None` if we are unable to resolve, either
     * because of ambiguity or due to insufficient inference.  Note
     * that selection is a shallow process and hence the result may
     * contain nested obligations that must be resolved. The caller is
     * responsible for ensuring that those get resolved. (But see
     * `try_select_obligation_deep` below.)
     */

    let selcx = select::SelectionContext::new(infcx, param_env);
    selcx.select(obligation)
}

pub fn evaluate_obligation(infcx: &InferCtxt,
                           param_env: &ty::ParameterEnvironment,
                           obligation: &Obligation)
                           -> EvaluationResult
{
    /*!
     * Attempts to resolve the obligation given. Returns `None` if
     * we are unable to resolve, either because of ambiguity or
     * due to insufficient inference.
     */

    let selcx = select::SelectionContext::new(infcx, param_env);
    selcx.evaluate_obligation(obligation)
}

pub fn evaluate_impl(infcx: &InferCtxt,
                     param_env: &ty::ParameterEnvironment,
                     span: Span,
                     impl_def_id: ast::DefId,
                     self_ty: ty::t)
                     -> EvaluationResult
{
    /*!
     */

    let selcx = select::SelectionContext::new(infcx, param_env);
    selcx.evaluate_impl(impl_def_id, span, self_ty)
}

pub fn select_inherent_impl(infcx: &InferCtxt,
                            param_env: &ty::ParameterEnvironment,
                            span: Span,
                            impl_def_id: ast::DefId,
                            self_ty: ty::t)
                            -> SelectionResult<VtableImpl<Obligation>>
{
    /*!
     * Matches the self type of the inherent impl `impl_def_id`
     * against `self_ty` and returns the resulting resolution.  This
     * routine may modify the surrounding type context (for example,
     * it may unify variables).
     */

    // This routine is only suitable for inherent impls. This is
    // because it does not attempt to unify the output type parameters
    // from the trait ref against the values from the obligation.
    // (These things do not apply to inherent impls, for which there
    // is no trait ref nor obligation.)
    //
    // Matching against non-inherent impls should be done with
    // `try_resolve_obligation()`.
    assert!(ty::impl_trait_ref(infcx.tcx, impl_def_id).is_none());

    let selcx = select::SelectionContext::new(infcx, param_env);
    selcx.select_inherent_impl(impl_def_id, span, self_ty)
}

pub fn is_orphan_impl(tcx: &ty::ctxt,
                      impl_def_id: ast::DefId)
                      -> bool
{
    /*!
     * True if neither the trait nor self type is local.
     */

    !coherence::impl_is_local(tcx, impl_def_id)
}

pub fn overlapping_impls(infcx: &InferCtxt,
                         impl1_def_id: ast::DefId,
                         impl2_def_id: ast::DefId)
                         -> bool
{
    /*!
     * True if there exist types that satisfy both of the two given impls.
     */

    coherence::impl_can_satisfy(infcx, impl1_def_id, impl2_def_id) &&
    coherence::impl_can_satisfy(infcx, impl2_def_id, impl1_def_id)
}

pub fn obligations_for_generics(tcx: &ty::ctxt,
                                span: Span,
                                generics: &ty::Generics,
                                substs: &subst::Substs)
                                -> subst::VecPerParamSpace<Obligation>
{
    /*!
     * Given a set of generic parameter definitions `generics`, along
     * with an appropriate set of substitutions, returns
     */

    util::obligations(tcx, span, 0, generics, substs)
}

pub fn search_trait_and_supertraits_from_bound(tcx: &ty::ctxt,
                                               space: subst::ParamSpace,
                                               i: uint,
                                               caller_bound: Rc<ty::TraitRef>,
                                               test: |ast::DefId| -> bool)
                                               -> Option<VtableParam>
{
    /*!
     * Utility function for searching through the trait/supertraits of
     * some bound for a trait with def-id `d` that meets `test(d)`.
     * If one is found, returns a `VtableParam` detailing the path through
     * the traits/supertraits.
     */

    util::search_trait_and_supertraits_from_bound(tcx, space, i, caller_bound,
                                                  test)
}

impl Obligation {
    pub fn new(span: Span, trait_ref: Rc<ty::TraitRef>) -> Obligation {
        Obligation { span: span,
                     recursion_depth: 0,
                     trait_ref: trait_ref }
    }

    pub fn self_ty(&self) -> ty::t {
        self.trait_ref.self_ty()
    }
}

impl<N> Vtable<N> {
    pub fn map_nested<M>(&self, op: |&N| -> M) -> Vtable<M> {
        match *self {
            VtableImpl(ref i) => VtableImpl(i.map_nested(op)),
            VtableUnboxedClosure(d) => VtableUnboxedClosure(d),
            VtableParam(ref p) => VtableParam((*p).clone()),
            VtableBuiltin => VtableBuiltin,
        }
    }

    pub fn map_move_nested<M>(self, op: |N| -> M) -> Vtable<M> {
        match self {
            VtableImpl(i) => VtableImpl(i.map_move_nested(op)),
            VtableUnboxedClosure(d) => VtableUnboxedClosure(d),
            VtableParam(p) => VtableParam(p),
            VtableBuiltin => VtableBuiltin,
        }
    }
}

impl<N> VtableImpl<N> {
    pub fn map_nested<M>(&self, op: |&N| -> M) -> VtableImpl<M> {
        VtableImpl {
            impl_def_id: self.impl_def_id,
            substs: self.substs.clone(),
            nested: self.nested.map(op)
        }
    }

    pub fn map_move_nested<M>(self, op: |N| -> M) -> VtableImpl<M> {
        let VtableImpl { impl_def_id, substs, nested } = self;
        VtableImpl {
            impl_def_id: impl_def_id,
            substs: substs,
            nested: nested.map_move(op)
        }
    }
}

impl EvaluationResult {
    pub fn potentially_applicable(&self) -> bool {
        match *self {
            EvaluatedToMatch | EvaluatedToAmbiguity => true,
            EvaluatedToUnmatch => false
        }
    }
}

impl<'o> FulfillmentError<'o> {
    fn new(obligation: &'o Obligation, code: FulfillmentErrorCode)
           -> FulfillmentError<'o>
    {
        FulfillmentError { obligation: obligation, code: code }
    }
}
